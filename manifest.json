/**
 * Uzaktan içerik servisi - GitHub + JSDelivr üzerinden manifest çeker.
 * Dil ve tarih aralığına göre filtreleyip uygun resimleri döndürür.
 */
import { getCache, setCache, CACHE_KEYS, CACHE_EXPIRY } from './cache';

const REMOTE_CONTENT_BASE = 'https://cdn.jsdelivr.net/gh/ismile94/nidaunnur-content@main';
const REMOTE_CONTENT_FALLBACK_BASE = 'https://raw.githubusercontent.com/ismile94/nidaunnur-content/main';
const PURGE_BASE = 'https://purge.jsdelivr.net/gh/ismile94/nidaunnur-content@main';
const GITHUB_API_BASE = 'https://api.github.com/repos/ismile94/nidaunnur-content/contents';
const IMAGE_EXTENSIONS = /\.(png|jpg|jpeg|gif|webp)$/i;
const MANIFEST_URLS = [
  `${REMOTE_CONTENT_BASE}/manifest.json`,
  `${REMOTE_CONTENT_FALLBACK_BASE}/manifest.json`,
];
const LOCALE_FALLBACK_CHAIN = ['en', 'tr'];
const DISABLE_REMOTE_CONTENT_CACHE = true;

/**
 * Full image URL oluşturur (path'teki boşlukları encode eder)
 */
function buildImageUrl(relativePath, baseUrl = REMOTE_CONTENT_BASE, cacheBustToken = null) {
  if (!relativePath) return null;
  if (/^https?:\/\//i.test(relativePath)) {
    if (!cacheBustToken) return relativePath;
    const sep = relativePath.includes('?') ? '&' : '?';
    return `${relativePath}${sep}v=${encodeURIComponent(cacheBustToken)}`;
  }
  const encoded = relativePath
    .split('/')
    .map((segment) => encodeURIComponent(segment))
    .join('/');
  const url = `${baseUrl}/${encoded}`;
  if (!cacheBustToken) return url;
  return `${url}?v=${encodeURIComponent(cacheBustToken)}`;
}

/**
 * GitHub API ile klasördeki resim dosyalarını listeler (isimlere bakılmaksızın)
 */
async function fetchFolderImages(folderPath) {
  try {
    const res = await fetch(`${GITHUB_API_BASE}/${folderPath}`, {
      headers: { Accept: 'application/vnd.github.v3+json' },
    });
    if (!res.ok) return [];
    const files = await res.json();
    if (!Array.isArray(files)) return [];
    return files
      .filter((f) => f.type === 'file' && IMAGE_EXTENSIONS.test(f.name || ''))
      .map((f) => ({ name: f.name, path: f.path || `${folderPath.replace(/\/$/, '')}/${f.name}` }))
      .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
  } catch (_) {
    return [];
  }
}

/**
 * imageFolder içeren item'ları klasördeki resimlere göre genişletir
 */
async function expandFolderItems(items, sourceBase, cacheBustToken) {
  const expanded = [];
  for (const item of items) {
    const folderPath = item.imageFolder;
    if (folderPath && typeof folderPath === 'string') {
      const images = await fetchFolderImages(folderPath);
      for (let i = 0; i < images.length; i++) {
        const img = images[i];
        expanded.push({
          ...item,
          id: `${item.id || 'folder'}-${i}`,
          imageUrl: img.path,
        });
      }
    } else if (item.imageUrl) {
      expanded.push(item);
    }
  }
  return expanded;
}

/**
 * JSDelivr CDN cache'ini temizler (GitHub'daki güncel dosyaların görünmesi için)
 * manifest.json + images/ramadan/ path'lerini purge eder
 */
async function purgeJSDelivrCache() {
  const pathsToPurge = ['/manifest.json', '/images/ramadan/'];
  try {
    await Promise.all(
      pathsToPurge.map((p) =>
        Promise.race([
          fetch(`${PURGE_BASE}${p}`, { method: 'GET' }),
          new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 2000)),
        ])
      )
    );
  } catch (_) {
    // Purge başarısız olsa da devam et
  }
}

/**
 * Manifest'i fetch eder (önce cache'e bakar)
 */
async function fetchManifest() {
  const cacheKey = CACHE_KEYS.REMOTE_CONTENT;
  const cached = DISABLE_REMOTE_CONTENT_CACHE ? { cached: false, data: null } : await getCache(cacheKey);
  if (!DISABLE_REMOTE_CONTENT_CACHE && cached.cached && cached.data) return cached.data;

  // JSDelivr cache'ini temizle - GitHub'da güncellenen resimlerin görünmesi için
  await purgeJSDelivrCache();

  try {
    for (const manifestUrl of MANIFEST_URLS) {
      try {
        const cacheBust = Date.now();
        const requestUrl = `${manifestUrl}?t=${cacheBust}`;
        const res = await fetch(requestUrl, {
          headers: {
            'Cache-Control': 'no-store, no-cache, must-revalidate',
            Pragma: 'no-cache',
          },
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (data?.items) {
          const sourceBase = requestUrl.replace(/\?t=.*$/i, '').replace(/\/manifest\.json$/i, '');
          const normalized = {
            ...data,
            _sourceBase: sourceBase,
            _cacheBustToken: data?.updatedAt || String(cacheBust),
          };
          if (!DISABLE_REMOTE_CONTENT_CACHE) {
            await setCache(cacheKey, normalized, CACHE_EXPIRY.REMOTE_CONTENT);
          }
          return normalized;
        }
      } catch (_) {
        // Bir sonraki repo endpoint'i denensin.
      }
    }
    throw new Error('All remote manifest endpoints failed');
  } catch (err) {
    if (cached.cached && cached.data) return cached.data;
    return { items: [] };
  }
}

function getLocalePriority(locale) {
  const normalized = (locale || '').toLowerCase();
  const chain = [normalized, ...LOCALE_FALLBACK_CHAIN];
  return chain.filter((value, index) => value && chain.indexOf(value) === index);
}

function getTypedLocalizedValue(manifest, type, locale, field) {
  const byType = manifest?.localizedTextByType?.[type];
  if (!byType) return null;
  const locales = getLocalePriority(locale);
  for (const code of locales) {
    const value = byType?.[code]?.[field];
    if (typeof value === 'string' && value.trim() !== '') {
      return value;
    }
  }
  return null;
}

function getItemLocalizedValue(item, locale, field) {
  const locales = getLocalePriority(locale);
  for (const code of locales) {
    const value = item?.locales?.[code]?.[field];
    if (typeof value === 'string' && value.trim() !== '') {
      return value;
    }
  }
  return null;
}

function getSpecialDayLocalizedValue(entry, locale, field) {
  const locales = getLocalePriority(locale);
  for (const code of locales) {
    const value = entry?.locales?.[code]?.[field];
    if (typeof value === 'string' && value.trim() !== '') {
      return value;
    }
  }
  return null;
}

function getSpecialDayEntry(manifest, type, today) {
  const specialDays = manifest?.specialDays || [];
  if (!Array.isArray(specialDays) || specialDays.length === 0) return null;
  const matches = specialDays.filter(
    (entry) =>
      entry?.type === type &&
      entry?.startDate <= today &&
      entry?.endDate >= today
  );
  if (matches.length === 0) return null;
  // Overlap varsa daha ozel (daha gec baslayan) araligi sec.
  matches.sort((a, b) => (a.startDate < b.startDate ? 1 : a.startDate > b.startDate ? -1 : 0));
  return matches[0];
}

function supportsLocale(item, locale, manifest) {
  const locales = getLocalePriority(locale);
  const hasItemLocale = locales.some((code) => !!item?.locales?.[code]);
  if (hasItemLocale) return true;
  const hasTypeLocale = locales.some(
    (code) => !!manifest?.localizedTextByType?.[item?.type]?.[code]
  );
  if (hasTypeLocale) return true;
  return item.lang === locale;
}

function getContentPool(items, locale, manifest, today) {
  const inDateRange = items.filter(
    (item) =>
      item.startDate <= today &&
      item.endDate >= today
  );
  const matching = inDateRange.filter((item) => supportsLocale(item, locale, manifest));

  // Dil eşleşmezse fallback: en, sonra tr
  let pool = matching;
  if (pool.length === 0) {
    pool = inDateRange.filter(
      (item) =>
        supportsLocale(item, 'en', manifest)
    );
  }
  if (pool.length === 0) {
    pool = inDateRange.filter(
      (item) =>
        supportsLocale(item, 'tr', manifest)
    );
  }
  return pool;
}

function mapRemoteItem(chosen, manifest, locale, today, sourceBase, cacheBustToken) {
  const specialDayEntry = getSpecialDayEntry(manifest, chosen.type, today);
  const shareText =
    getSpecialDayLocalizedValue(specialDayEntry, locale, 'shareText') ||
    getItemLocalizedValue(chosen, locale, 'shareText') ||
    getTypedLocalizedValue(manifest, chosen.type, locale, 'shareText') ||
    chosen.shareText ||
    null;
  const quoteText =
    getSpecialDayLocalizedValue(specialDayEntry, locale, 'quoteText') ||
    getItemLocalizedValue(chosen, locale, 'quoteText') ||
    getTypedLocalizedValue(manifest, chosen.type, locale, 'quoteText') ||
    null;

  return {
    id: chosen.id,
    imageUrl: buildImageUrl(chosen.imageUrl, sourceBase, cacheBustToken),
    shareText,
    quoteText,
    type: chosen.type,
    specialDayId: specialDayEntry?.id || null,
    quoteKey: chosen.quoteKey || null,
  };
}

/**
 * Kullanıcının diline ve bugünün tarihine uygun tek bir öğe döndürür.
 * @param {string} locale - tr, en, ar, pt, es, de, nl
 * @returns {Promise<{imageUrl: string, shareText?: string, quoteText?: string, id?: string, type?: string, quoteKey?: string} | null>}
 */
export async function getRemoteContentItem(locale) {
  const manifest = await fetchManifest();
  const items = manifest?.items || [];
  if (items.length === 0) return null;
  const sourceBase = manifest?._sourceBase || REMOTE_CONTENT_BASE;
  const cacheBustToken = DISABLE_REMOTE_CONTENT_CACHE
    ? String(Date.now())
    : manifest?._cacheBustToken || manifest?.updatedAt || null;

  const today = new Date().toISOString().slice(0, 10);

  const pool = getContentPool(items, locale, manifest, today);
  if (pool.length === 0) return null;

  const expandedPool = await expandFolderItems(pool, sourceBase, cacheBustToken);
  if (expandedPool.length === 0) return null;

  const chosen = expandedPool[Math.floor(Math.random() * expandedPool.length)];
  return mapRemoteItem(chosen, manifest, locale, today, sourceBase, cacheBustToken);
}

export async function getRemoteContentItems(locale) {
  const manifest = await fetchManifest();
  const items = manifest?.items || [];
  if (items.length === 0) return [];
  const sourceBase = manifest?._sourceBase || REMOTE_CONTENT_BASE;
  const today = new Date().toISOString().slice(0, 10);
  const cacheBustToken = DISABLE_REMOTE_CONTENT_CACHE
    ? String(Date.now())
    : manifest?._cacheBustToken || manifest?.updatedAt || null;

  const pool = getContentPool(items, locale, manifest, today);
  if (pool.length === 0) return [];
  const expandedPool = await expandFolderItems(pool, sourceBase, cacheBustToken);
  if (expandedPool.length === 0) return [];
  return expandedPool.map((entry) =>
    mapRemoteItem(entry, manifest, locale, today, sourceBase, cacheBustToken)
  );
}
